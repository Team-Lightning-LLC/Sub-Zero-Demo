<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sub-Zero</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    :root {
      --white: #FFFFFF;
      --cream: #FFFDF7;
      --beige-light: #F9F6EF;
      --beige: #EBE6DC;
      --charcoal: #343633;
      --charcoal-light: #4a4d48;
      --accent: #8B7355;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'IBM Plex Sans', -apple-system, sans-serif;
      background: var(--beige-light);
      color: var(--charcoal);
      height: 100vh;
      overflow: hidden;
    }
    
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: var(--beige); }
    ::-webkit-scrollbar-thumb { background: rgba(52, 54, 51, 0.25); border-radius: 3px; }
    
    .container { display: flex; height: 100vh; padding: 24px; gap: 24px; }
    
    /* Document Panel */
    .doc-panel {
      width: 50%;
      display: flex;
      flex-direction: column;
      background: var(--white);
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(52, 54, 51, 0.08);
      overflow: hidden;
    }
    
    .doc-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--beige);
      background: var(--cream);
    }
    
    .doc-header h2 {
      font-size: 16px;
      font-weight: 600;
      color: var(--charcoal);
    }
    
    .doc-header-sub {
      font-size: 12px;
      color: var(--charcoal-light);
      margin-top: 4px;
      opacity: 0.7;
    }
    
    .doc-list {
      flex: 1;
      overflow: auto;
    }
    
    /* Table Styles */
    .doc-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    
    .doc-table th {
      text-align: left;
      padding: 12px 16px;
      background: var(--beige-light);
      border-bottom: 1px solid var(--beige);
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--charcoal-light);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    
    .doc-table td {
      padding: 12px 16px;
      border-bottom: 1px solid var(--beige);
      vertical-align: middle;
    }
    
    .doc-table tr {
      cursor: pointer;
      transition: background 0.15s;
    }
    
    .doc-table tbody tr:hover {
      background: var(--cream);
    }
    
    .doc-name {
      color: var(--charcoal);
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .doc-name-icon {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      background: var(--beige-light);
      border: 1px solid var(--beige);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
    }
    
    .doc-type {
      color: var(--charcoal-light);
      font-size: 12px;
    }
    
    .doc-type-badge {
      display: inline-block;
      padding: 4px 10px;
      background: var(--beige-light);
      border-radius: 12px;
      font-size: 11px;
    }
    
    /* Document Viewer Modal */
    .doc-viewer-overlay {
      position: fixed;
      inset: 0;
      background: rgba(52, 54, 51, 0.6);
      backdrop-filter: blur(4px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      opacity: 0;
      visibility: hidden;
      transition: all 0.25s ease;
    }
    
    .doc-viewer-overlay.open {
      opacity: 1;
      visibility: visible;
    }
    
    .doc-viewer {
      background: var(--white);
      border-radius: 16px;
      width: 100%;
      max-width: 900px;
      height: 85vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 24px 80px rgba(0,0,0,0.25);
      transform: translateY(20px) scale(0.98);
      transition: transform 0.25s ease;
    }
    
    .doc-viewer-overlay.open .doc-viewer {
      transform: translateY(0) scale(1);
    }
    
    .doc-viewer-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--beige);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--charcoal);
      border-radius: 16px 16px 0 0;
      color: var(--white);
    }
    
    .doc-viewer-title {
      font-size: 15px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .doc-viewer-title-icon {
      width: 32px;
      height: 32px;
      background: rgba(255,255,255,0.15);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .doc-viewer-close {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      border: none;
      background: rgba(255,255,255,0.1);
      color: var(--white);
      cursor: pointer;
      font-size: 18px;
      transition: background 0.15s;
    }
    
    .doc-viewer-close:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .doc-viewer-content {
      flex: 1;
      overflow: auto;
      padding: 32px 40px;
      line-height: 1.8;
      font-size: 14px;
    }
    
    /* When showing PDF, remove padding */
    .doc-viewer-content:has(iframe) {
      padding: 0;
      overflow: hidden;
    }
    
    .doc-viewer-content h1 { font-size: 24px; color: var(--charcoal); margin-bottom: 16px; border-bottom: 2px solid var(--beige); padding-bottom: 12px; }
    .doc-viewer-content h2 { font-size: 18px; color: var(--charcoal); margin: 28px 0 12px; font-weight: 600; }
    .doc-viewer-content h3 { font-size: 15px; color: var(--charcoal-light); margin: 20px 0 10px; font-weight: 600; }
    .doc-viewer-content p { margin-bottom: 14px; color: var(--charcoal); opacity: 0.9; }
    .doc-viewer-content ul, .doc-viewer-content ol { margin: 12px 0 12px 28px; }
    .doc-viewer-content li { margin-bottom: 8px; }
    .doc-viewer-content table { width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 13px; }
    .doc-viewer-content th { background: var(--beige-light); padding: 10px 14px; text-align: left; border: 1px solid var(--beige); font-weight: 600; }
    .doc-viewer-content td { padding: 10px 14px; border: 1px solid var(--beige); }
    .doc-viewer-content code { background: var(--beige-light); padding: 2px 6px; border-radius: 4px; font-family: 'IBM Plex Mono', monospace; font-size: 13px; }
    .doc-viewer-content pre { background: var(--beige-light); padding: 16px; border-radius: 8px; overflow-x: auto; margin: 16px 0; }
    .doc-viewer-content blockquote { border-left: 4px solid var(--accent); padding: 12px 20px; margin: 20px 0; background: var(--cream); border-radius: 0 8px 8px 0; }
    .doc-viewer-content strong { color: var(--charcoal); font-weight: 600; }
    
    .doc-viewer-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: var(--charcoal-light);
      gap: 12px;
    }
    
    .loading-state, .error-state {
      text-align: center;
      padding: 40px;
      color: var(--charcoal-light);
      opacity: 0.6;
    }
    
    .error-state { color: #b85c5c; }
    
    /* Chat Panel */
    .chat-panel { 
      width: 50%; 
      display: flex; 
      flex-direction: column; 
      background: var(--white);
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(52, 54, 51, 0.08);
      overflow: hidden;
    }
    
    .chat-header { 
      padding: 20px 24px; 
      border-bottom: 1px solid var(--beige); 
      background: var(--cream); 
    }
    
    .chat-header h2 { font-size: 16px; font-weight: 600; color: var(--charcoal); }
    .chat-subtitle { font-size: 12px; color: var(--charcoal-light); margin-top: 4px; opacity: 0.7; }
    
    .chat-messages { 
      flex: 1; 
      overflow: auto; 
      padding: 24px; 
      display: flex; 
      flex-direction: column; 
      gap: 16px; 
      background: var(--beige-light); 
    }
    
    .message { 
      max-width: 85%; 
      padding: 14px 18px; 
      border-radius: 14px; 
      font-size: 14px; 
      line-height: 1.6; 
      animation: fadeIn 0.3s ease; 
    }
    
    @keyframes fadeIn { 
      from { opacity: 0; transform: translateY(10px); } 
      to { opacity: 1; transform: translateY(0); } 
    }
    
    .message.user { 
      align-self: flex-end; 
      background: var(--charcoal); 
      color: var(--white); 
      border-bottom-right-radius: 4px; 
    }
    
    .message.assistant { 
      align-self: flex-start; 
      background: var(--white); 
      border: 1px solid var(--beige); 
      border-bottom-left-radius: 4px; 
      color: var(--charcoal); 
      box-shadow: 0 2px 8px rgba(52, 54, 51, 0.04); 
    }
    
    .message.assistant p { margin-bottom: 10px; }
    .message.assistant p:last-child { margin-bottom: 0; }
    .message.assistant ul { margin: 8px 0 8px 20px; }
    .message.assistant strong { color: var(--charcoal); font-weight: 600; }
    .message.assistant code { background: var(--beige-light); padding: 2px 5px; border-radius: 3px; font-family: 'IBM Plex Mono', monospace; font-size: 12px; }
    .message.assistant a { color: var(--accent); text-decoration: underline; cursor: pointer; font-weight: 500; }
    .message.assistant a:hover { color: var(--charcoal); }
    
    .typing { display: flex; gap: 5px; padding: 8px 0; }
    .typing span { width: 8px; height: 8px; background: var(--charcoal-light); border-radius: 50%; animation: bounce 1.4s infinite ease-in-out; opacity: 0.5; }
    .typing span:nth-child(1) { animation-delay: -0.32s; }
    .typing span:nth-child(2) { animation-delay: -0.16s; }
    @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }
    
    .chat-input-area { 
      padding: 18px 24px; 
      border-top: 1px solid var(--beige); 
      background: var(--white); 
    }
    
    .chat-input-wrapper { display: flex; gap: 12px; }
    
    .chat-input { 
      flex: 1; 
      padding: 14px 18px; 
      background: var(--beige-light); 
      border: 1px solid var(--beige); 
      border-radius: 12px; 
      color: var(--charcoal); 
      font-size: 14px; 
      font-family: inherit; 
      resize: none; 
      outline: none; 
      transition: border-color 0.2s; 
    }
    
    .chat-input:focus { border-color: var(--charcoal-light); }
    .chat-input::placeholder { color: var(--charcoal-light); opacity: 0.5; }
    
    .send-btn { 
      width: 52px; 
      height: 52px; 
      border-radius: 12px; 
      border: none; 
      background: var(--charcoal); 
      color: var(--white); 
      cursor: pointer; 
      font-size: 18px; 
      transition: all 0.2s; 
    }
    
    .send-btn:hover { background: var(--charcoal-light); }
    .send-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  </style>
</head>
<body>
  <div class="container">
    <!-- Left: Document List -->
    <div class="doc-panel">
      <div class="doc-header">
        <h2>Documentation</h2>
        <div class="doc-header-sub">Click a document to view</div>
      </div>
      <div class="doc-list" id="docList">
        <div class="loading-state">Loading documents...</div>
      </div>
    </div>
    
    <!-- Document Viewer Modal -->
    <div class="doc-viewer-overlay" id="docViewerOverlay" onclick="Documents.closeViewer(event)">
      <div class="doc-viewer" onclick="event.stopPropagation()">
        <div class="doc-viewer-header">
          <div class="doc-viewer-title">
            <div class="doc-viewer-title-icon">üìÑ</div>
            <span id="docViewerTitle">Document</span>
          </div>
          <button class="doc-viewer-close" onclick="Documents.closeViewer()">‚úï</button>
        </div>
        <div class="doc-viewer-content" id="docViewerContent">
          <div class="doc-viewer-loading">
            <div class="typing"><span></span><span></span><span></span></div>
            Loading document...
          </div>
        </div>
      </div>
    </div>
    
    <!-- Right: Chat -->
    <div class="chat-panel">
      <div class="chat-header">
        <h2>Machinery Servicing Terminal</h2>
        <div class="chat-subtitle">Powered by Vertesia</div>
      </div>
      
      <div class="chat-messages" id="chatMessages">
        <div class="message assistant">
          <p>Search across all loaded documentation to answer your questions about machinery maintenance, troubleshooting, parts, and safety.</p>
        </div>
      </div>
      
      <div class="chat-input-area">
        <div class="chat-input-wrapper">
          <textarea class="chat-input" id="chatInput" placeholder="Ask about servicing and maintenance..." rows="1" onkeydown="Chat.handleKey(event)"></textarea>
          <button class="send-btn" id="sendBtn" onclick="Chat.send()">‚ñ∂</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      BASE_URL: 'https://api.vertesia.io/api/v1',
      API_KEY: 'sk-5a8f617b5184233f6191aa5609bf52b3',
      ENVIRONMENT_ID: '681915c6a01fb262a410c161',
      MODEL: 'publishers/anthropic/models/claude-sonnet-4',
      INTERACTION: 'DocumentChat'  // Must match your Vertesia interaction name exactly
    };

    // ============================================
    // VERTESIA API (Clean implementation)
    // ============================================
    const Vertesia = {
      async call(endpoint, options = {}) {
        const url = `${CONFIG.BASE_URL}${endpoint}`;
        const response = await fetch(url, {
          headers: {
            'Authorization': `Bearer ${CONFIG.API_KEY}`,
            'Content-Type': 'application/json',
            ...options.headers
          },
          ...options
        });
        
        if (!response.ok) {
          const text = await response.text();
          throw new Error(`API ${response.status}: ${text}`);
        }
        
        return response.json();
      },

      // Load all document objects
      async loadObjects() {
        return this.call('/objects?limit=1000');
      },

      // Get single object
      async getObject(id) {
        return this.call(`/objects/${encodeURIComponent(id)}`);
      },

      // Get download URL and fetch content
      async getContent(fileRef) {
        const { url } = await this.call('/objects/download-url', {
          method: 'POST',
          body: JSON.stringify({ file: fileRef, format: 'original' })
        });
        const response = await fetch(url);
        if (!response.ok) throw new Error('Download failed');
        return response.text();
      },

      // Execute async interaction - returns { runId, workflowId }
      async executeChat(task) {
        return this.call('/execute/async', {
          method: 'POST',
          body: JSON.stringify({
            type: 'conversation',
            interaction: CONFIG.INTERACTION,
            data: { task },
            config: {
              environment: CONFIG.ENVIRONMENT_ID,
              model: CONFIG.MODEL
            },
            // These might be needed for the agent to actually run
            interactive: true,
            max_iterations: 100
          })
        });
      },

      // Stream response from workflow run
      async streamResponse(workflowId, runId, onMessage, onComplete, onError) {
        const url = `${CONFIG.BASE_URL}/workflows/runs/${workflowId}/${runId}/stream?since=${Date.now()}&access_token=${CONFIG.API_KEY}`;
        
        console.log('[Stream] Opening:', url);
        
        try {
          const response = await fetch(url);
          
          if (!response.ok) {
            throw new Error(`Stream failed: ${response.status}`);
          }
          
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          
          while (true) {
            const { done, value } = await reader.read();
            
            if (done) {
              console.log('[Stream] Ended');
              onComplete?.();
              break;
            }
            
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop(); // Keep incomplete line
            
            for (const line of lines) {
              if (!line.startsWith('data:')) continue;
              
              try {
                const data = JSON.parse(line.slice(5).trim());
                console.log('[Stream] Data:', data);
                onMessage?.(data);
                
                // Check for completion signals
                if (data.type === 'finish' || data.finish_reason === 'stop') {
                  console.log('[Stream] Complete signal');
                  onComplete?.();
                  return;
                }
              } catch (e) {
                // Ignore parse errors for non-JSON lines
              }
            }
          }
        } catch (error) {
          console.error('[Stream] Error:', error);
          onError?.(error);
        }
      }
    };

    // ============================================
    // DOCUMENT LOADING (Fast - metadata only)
    // ============================================
    const Documents = {
      items: [],
      contentCache: {}, // Cache loaded content

      async load() {
        const docList = document.getElementById('docList');
        
        try {
          const data = await Vertesia.loadObjects();
          const objects = Array.isArray(data) ? data : data.objects || [];
          
          console.log(`[Docs] Found ${objects.length} objects`);

          // Just store metadata - don't fetch content yet
          this.items = objects.map(obj => ({
            id: obj.id,
            name: obj.name || 'Untitled',
            type: this.inferType(obj),
            fileType: this.getFileType(obj.name),
            source: obj.content?.source || null
          })).filter(doc => doc.name);

          if (this.items.length === 0) {
            docList.innerHTML = '<div class="error-state">No documents found</div>';
            return;
          }

          this.render();

        } catch (error) {
          console.error('[Docs] Load failed:', error);
          docList.innerHTML = `<div class="error-state">Failed to load: ${error.message}</div>`;
        }
      },

      getFileType(name) {
        const n = (name || '').toLowerCase();
        if (n.endsWith('.pdf')) return 'pdf';
        if (n.endsWith('.docx') || n.endsWith('.doc')) return 'docx';
        if (n.endsWith('.xlsx') || n.endsWith('.xls')) return 'xlsx';
        if (n.endsWith('.md')) return 'markdown';
        if (n.endsWith('.txt')) return 'text';
        return 'unknown';
      },

      inferType(obj) {
        const name = (obj.name || '').toLowerCase();
        const props = obj.properties || {};
        
        if (props.document_type) return props.document_type;
        if (props.type) return props.type;
        
        if (name.includes('manual')) return 'Equipment Manual';
        if (name.includes('maintenance') || name.includes('pm')) return 'Maintenance Instruction';
        if (name.includes('datasheet')) return 'Equipment Datasheet';
        if (name.includes('template')) return 'Template';
        if (name.includes('filter') || name.includes('chiller') || name.includes('robot')) return 'Equipment Manual';
        
        return 'Document';
      },

      getIcon(doc) {
        // Icon by file type first
        if (doc.fileType === 'pdf') return 'üìï';
        if (doc.fileType === 'docx') return 'üìò';
        if (doc.fileType === 'xlsx') return 'üìä';
        
        // Then by document type
        const t = doc.type.toLowerCase();
        if (t.includes('manual')) return 'üìò';
        if (t.includes('maintenance')) return 'üîß';
        if (t.includes('datasheet')) return 'üìä';
        if (t.includes('template')) return 'üìã';
        return 'üìÑ';
      },

      render() {
        const docList = document.getElementById('docList');
        
        docList.innerHTML = `
          <table class="doc-table">
            <thead>
              <tr>
                <th>Name</th>
                <th>Type</th>
              </tr>
            </thead>
            <tbody>
              ${this.items.map((doc, i) => `
                <tr onclick="Documents.openViewer(${i})">
                  <td>
                    <div class="doc-name">
                      <div class="doc-name-icon">${this.getIcon(doc)}</div>
                      ${this.escapeHtml(doc.name)}
                    </div>
                  </td>
                  <td>
                    <span class="doc-type-badge">${this.escapeHtml(doc.type)}</span>
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        `;
      },

      async openViewer(index, targetPage = null) {
        const doc = this.items[index];
        const overlay = document.getElementById('docViewerOverlay');
        const title = document.getElementById('docViewerTitle');
        const content = document.getElementById('docViewerContent');
        
        // Open modal
        overlay.classList.add('open');
        title.textContent = doc.name + (targetPage ? ` - Page ${targetPage}` : '');
        document.body.style.overflow = 'hidden';
        
        // Show loading
        content.innerHTML = `
          <div class="doc-viewer-loading">
            <div class="typing"><span></span><span></span><span></span></div>
            Loading document...
          </div>
        `;
        
        try {
          // Get the full object to find the source
          const fullObj = await Vertesia.getObject(doc.id);
          const source = fullObj.content?.source;
          
          if (!source) {
            content.innerHTML = '<div class="error-state">No content source found</div>';
            return;
          }
          
          // Get the file reference
          let fileRef = typeof source === 'string' ? source : (source.file || source.store || source.path);
          
          if (!fileRef) {
            // Source might be inline text
            if (typeof source === 'string' && !source.includes('/')) {
              content.innerHTML = marked.parse(source);
              return;
            }
            content.innerHTML = '<div class="error-state">Could not determine file location</div>';
            return;
          }
          
          // For PDFs - get download URL and embed
          if (doc.fileType === 'pdf') {
            const { url } = await Vertesia.call('/objects/download-url', {
              method: 'POST',
              body: JSON.stringify({ file: fileRef, format: 'original' })
            });
            
            // Add page fragment if specified
            const pdfUrl = targetPage ? `${url}#page=${targetPage}` : url;
            
            content.innerHTML = `
              <iframe 
                src="${pdfUrl}" 
                style="width: 100%; height: 100%; border: none;"
                title="${this.escapeHtml(doc.name)}"
              ></iframe>
            `;
            return;
          }
          
          // For text/markdown - fetch and render (with size limit)
          const text = await Vertesia.getContent(fileRef);
          
          // If text is huge, truncate with warning
          const MAX_CHARS = 500000; // ~500KB
          if (text.length > MAX_CHARS) {
            content.innerHTML = `
              <div style="padding: 16px; background: #fff3cd; border-radius: 8px; margin-bottom: 20px; font-size: 13px;">
                ‚ö†Ô∏è This document is very large (${Math.round(text.length/1000)}KB). Showing first portion only.
              </div>
              ${marked.parse(text.substring(0, MAX_CHARS))}
              <div style="padding: 20px; text-align: center; color: var(--charcoal-light); border-top: 1px solid var(--beige); margin-top: 20px;">
                ... Document truncated. Full document is ${Math.round(text.length/1000)}KB.
              </div>
            `;
          } else {
            content.innerHTML = marked.parse(text);
          }
          
        } catch (error) {
          console.error('[Docs] Failed to load content:', error);
          content.innerHTML = `<div class="error-state">Failed to load document: ${error.message}</div>`;
        }
      },

      closeViewer(event) {
        if (event && event.target !== event.currentTarget) return;
        
        document.getElementById('docViewerOverlay').classList.remove('open');
        document.body.style.overflow = '';
        
        // Clear content to stop any embedded PDFs
        document.getElementById('docViewerContent').innerHTML = '';
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ============================================
    // CHAT (Clean implementation with progress)
    // ============================================
    const Chat = {
      history: [],
      isLoading: false,

      async send() {
        const input = document.getElementById('chatInput');
        const question = input.value.trim();
        
        if (!question || this.isLoading) return;

        input.value = '';
        this.setLoading(true);
        this.addMessage(question, 'user');
        
        // Show simple typing indicator
        const typingEl = this.showTyping();

        try {
          // Build task string with conversation history
          let task = question;
          if (this.history.length > 0) {
            const historyStr = this.history
              .map(m => `${m.role === 'user' ? 'User' : 'Assistant'}: ${m.content}`)
              .join('\n');
            task = `Previous conversation:\n${historyStr}\n\nCurrent question: ${question}`;
          }

          console.log('[Chat] Sending task:', task);

          // Execute async - get runId and workflowId
          const response = await Vertesia.executeChat(task);
          
          console.log('[Chat] Full response:', response);
          
          const runId = response.runId || response.run_id;
          const workflowId = response.workflowId || response.workflow_id;
          
          console.log('[Chat] runId:', runId, 'workflowId:', workflowId);

          if (!runId || !workflowId) {
            throw new Error('Missing runId or workflowId in response');
          }

          // Stream the response
          let answer = '';
          let answered = false;

          await Vertesia.streamResponse(
            workflowId,
            runId,
            // onMessage
            (data) => {
              console.log('[Chat] Stream data:', data.type, data.message?.substring(0, 100));
              
              // ONLY look for type: "answer" - ignore all updates
              if (data.type === 'answer' && data.message && !answered) {
                answered = true;
                
                // Extract just the Agent Answer part if it exists
                answer = this.extractAnswer(data.message);
                
                typingEl.remove();
                this.addMessage(answer, 'assistant');
                
                // Re-enable input immediately after answer
                this.setLoading(false);
              }
            },
            // onComplete
            () => {
              console.log('[Chat] Stream complete. Answered:', answered);
              
              if (!answered) {
                typingEl.remove();
                this.addMessage('The agent completed but returned no response. Please try again.', 'assistant');
                this.setLoading(false);
              }
              // If already answered, setLoading(false) was already called
            },
            // onError
            (error) => {
              typingEl.remove();
              this.addMessage(`Error: ${error.message}`, 'assistant');
              this.setLoading(false);
            }
          );

          // Save to history
          this.history.push({ role: 'user', content: question });
          if (answer) {
            this.history.push({ role: 'assistant', content: answer });
          }

        } catch (error) {
          console.error('[Chat] Error:', error);
          typingEl.remove();
          this.addMessage(`Error: ${error.message}`, 'assistant');
          this.setLoading(false);
        }
      },

      // Extract just the answer portion from the agent response
      extractAnswer(fullMessage) {
        // The agent returns formatted like:
        // **1. User Query:** ...
        // **2. Resources Search:** ...
        // **3. Agent Answer:** [THE ACTUAL ANSWER]
        
        // Try to extract just the Agent Answer section
        const answerMatch = fullMessage.match(/\*\*3\.\s*Agent Answer:\*\*\s*([\s\S]*?)(?=\*\*\d+\.|$)/i);
        
        if (answerMatch && answerMatch[1].trim()) {
          return answerMatch[1].trim();
        }
        
        // If no structured format, return the whole message
        return fullMessage;
      },

      addMessage(text, role) {
        const container = document.getElementById('chatMessages');
        const div = document.createElement('div');
        div.className = `message ${role}`;
        div.innerHTML = role === 'assistant' ? marked.parse(text) : Documents.escapeHtml(text);
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
        return div;
      },

      showTyping() {
        const container = document.getElementById('chatMessages');
        const div = document.createElement('div');
        div.className = 'message assistant';
        div.innerHTML = `
          <div style="display: flex; align-items: center; gap: 10px;">
            <div class="typing"><span></span><span></span><span></span></div>
            <span class="status-text" style="font-size: 13px; opacity: 0.8;">Thinking...</span>
          </div>
        `;
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
        
        // Start cycling through status messages
        const messages = [
          "Thinking...",
          "Searching documents...",
          "Identifying context...",
          "Analyzing query...",
          "Reading manuals...",
          "Cross-referencing data...",
          "Finding relevant sections...",
          "Processing information...",
          "Checking maintenance logs...",
          "Reviewing specifications...",
          "Matching keywords...",
          "Scanning procedures...",
          "Evaluating sources...",
          "Compiling answer...",
          "Verifying details...",
          "Gathering insights...",
          "Consulting documentation...",
          "Parsing technical data...",
          "Locating best practices...",
          "Synthesizing response..."
        ];
        
        let lastIndex = -1;
        const statusText = div.querySelector('.status-text');
        
        const cycleStatus = () => {
          // Pick a random message that's different from the last one
          let newIndex;
          do {
            newIndex = Math.floor(Math.random() * messages.length);
          } while (newIndex === lastIndex);
          lastIndex = newIndex;
          
          if (statusText) {
            statusText.textContent = messages[newIndex];
          }
        };
        
        // Cycle every 2 seconds
        div.statusInterval = setInterval(cycleStatus, 2000);
        
        // Store original remove function and override to clear interval
        const originalRemove = div.remove.bind(div);
        div.remove = () => {
          clearInterval(div.statusInterval);
          originalRemove();
        };
        
        return div;
      },

      setLoading(loading) {
        this.isLoading = loading;
        document.getElementById('sendBtn').disabled = loading;
        document.getElementById('chatInput').disabled = loading;
        
        // Re-focus input when done
        if (!loading) {
          document.getElementById('chatInput').focus();
        }
      },

      handleKey(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.send();
        }
      },

      ask(question) {
        document.getElementById('chatInput').value = question;
        this.send();
      }
    };

    // ============================================
    // INIT
    // ============================================
    Documents.load();
    
    // Close modal on Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        Documents.closeViewer();
      }
    });
    
    // Intercept clicks on document links in chat
    document.getElementById('chatMessages').addEventListener('click', (e) => {
      const link = e.target.closest('a');
      if (!link) return;
      
      const linkText = link.textContent.trim();
      const href = link.getAttribute('href') || '';
      
      // Parse page number if present (e.g., "Manual.pdf - Page 5" or "- Pages 355-357")
      let targetPage = null;
      const pageMatch = linkText.match(/[-‚Äì]\s*[Pp]ages?\s*(\d+)/);
      if (pageMatch) {
        targetPage = parseInt(pageMatch[1], 10);
      }
      
      // Check if this matches any document name
      const docIndex = Documents.items.findIndex(doc => {
        const docName = doc.name.toLowerCase();
        const searchText = linkText.toLowerCase().split(/[-‚Äì]/)[0].trim(); // Get part before " - Page X"
        const searchHref = href.toLowerCase();
        
        return docName === searchText || 
               docName.includes(searchText) || 
               searchText.includes(docName.replace('.pdf', '').replace('.docx', '')) ||
               searchHref.includes(docName);
      });
      
      if (docIndex !== -1) {
        e.preventDefault();
        Documents.openViewer(docIndex, targetPage);
      }
    });
  </script>
</body>
</html>
