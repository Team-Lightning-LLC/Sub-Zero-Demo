<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sub-Zero</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    :root {
      --white: #FFFFFF;
      --cream: #FFFDF7;
      --beige-light: #F9F6EF;
      --beige: #EBE6DC;
      --charcoal: #343633;
      --charcoal-light: #4a4d48;
      --accent: #8B7355;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'IBM Plex Sans', -apple-system, sans-serif;
      background: var(--beige-light);
      color: var(--charcoal);
      height: 100vh;
      overflow: hidden;
    }
    
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: var(--beige); }
    ::-webkit-scrollbar-thumb { background: rgba(52, 54, 51, 0.25); border-radius: 3px; }
    
    .container { display: flex; height: 100vh; padding: 24px; gap: 24px; }
    
    /* Document Panel */
    .doc-panel {
      width: 50%;
      display: flex;
      flex-direction: column;
      background: var(--white);
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(52, 54, 51, 0.08);
      overflow: hidden;
    }
    
    .doc-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--beige);
      background: var(--cream);
    }
    
    .doc-header h2 {
      font-size: 16px;
      font-weight: 600;
      color: var(--charcoal);
    }
    
    .doc-header-sub {
      font-size: 12px;
      color: var(--charcoal-light);
      margin-top: 4px;
      opacity: 0.7;
    }
    
    .doc-list {
      flex: 1;
      overflow: auto;
      padding: 16px;
    }
    
    /* Document Item */
    .doc-item {
      border: 1px solid var(--beige);
      border-radius: 10px;
      margin-bottom: 12px;
      overflow: hidden;
      transition: all 0.2s;
    }
    
    .doc-item:hover { border-color: var(--charcoal-light); }
    .doc-item.expanded { border-color: var(--charcoal); }
    
    .doc-item-header {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      background: var(--cream);
      transition: background 0.2s;
    }
    
    .doc-item-header:hover { background: var(--beige-light); }
    
    .doc-item.expanded .doc-item-header {
      background: var(--charcoal);
      color: var(--white);
    }
    
    .doc-item-info { display: flex; align-items: center; gap: 12px; }
    
    .doc-item-icon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      background: var(--beige-light);
      border: 1px solid var(--beige);
    }
    
    .doc-item.expanded .doc-item-icon {
      background: rgba(255,255,255,0.15);
      border-color: rgba(255,255,255,0.2);
    }
    
    .doc-item-title { font-size: 14px; font-weight: 500; }
    .doc-item-meta { font-size: 11px; opacity: 0.6; margin-top: 2px; }
    .doc-item-toggle { font-size: 12px; opacity: 0.5; transition: transform 0.2s; }
    .doc-item.expanded .doc-item-toggle { transform: rotate(180deg); }
    
    .doc-item-content {
      display: none;
      padding: 20px;
      background: var(--white);
      max-height: 400px;
      overflow: auto;
      border-top: 1px solid var(--beige);
      line-height: 1.7;
    }
    
    .doc-item.expanded .doc-item-content { display: block; }
    
    /* Markdown styles in doc content */
    .doc-item-content h1 { font-size: 20px; color: var(--charcoal); margin-bottom: 10px; border-bottom: 2px solid var(--beige); padding-bottom: 10px; }
    .doc-item-content h2 { font-size: 16px; color: var(--charcoal); margin: 20px 0 10px; font-weight: 600; }
    .doc-item-content h3 { font-size: 13px; color: var(--charcoal-light); margin: 14px 0 8px; text-transform: uppercase; letter-spacing: 0.5px; }
    .doc-item-content p { margin-bottom: 12px; color: var(--charcoal); font-size: 13px; opacity: 0.85; }
    .doc-item-content ul, .doc-item-content ol { margin: 10px 0 10px 24px; font-size: 13px; opacity: 0.85; }
    .doc-item-content li { margin-bottom: 6px; }
    .doc-item-content table { width: 100%; border-collapse: collapse; margin: 14px 0; font-size: 12px; }
    .doc-item-content th { background: var(--beige-light); padding: 8px 10px; text-align: left; border: 1px solid var(--beige); font-weight: 600; }
    .doc-item-content td { padding: 8px 10px; border: 1px solid var(--beige); }
    .doc-item-content code { background: var(--beige-light); padding: 2px 5px; border-radius: 3px; font-family: 'IBM Plex Mono', monospace; font-size: 12px; }
    .doc-item-content blockquote { border-left: 3px solid var(--accent); padding: 10px 14px; margin: 14px 0; background: var(--cream); border-radius: 0 6px 6px 0; font-size: 13px; }
    .doc-item-content strong { color: var(--charcoal); font-weight: 600; }
    
    .loading-state, .error-state {
      text-align: center;
      padding: 40px;
      color: var(--charcoal-light);
      opacity: 0.6;
    }
    
    .error-state { color: #b85c5c; }
    
    /* Chat Panel */
    .chat-panel { 
      width: 50%; 
      display: flex; 
      flex-direction: column; 
      background: var(--white);
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(52, 54, 51, 0.08);
      overflow: hidden;
    }
    
    .chat-header { 
      padding: 20px 24px; 
      border-bottom: 1px solid var(--beige); 
      background: var(--cream); 
    }
    
    .chat-header h2 { font-size: 16px; font-weight: 600; color: var(--charcoal); }
    .chat-subtitle { font-size: 12px; color: var(--charcoal-light); margin-top: 4px; opacity: 0.7; }
    
    .suggestions { 
      padding: 14px 24px; 
      border-bottom: 1px solid var(--beige); 
      background: var(--cream); 
    }
    
    .suggestions-label { 
      font-size: 11px; 
      color: var(--charcoal-light); 
      margin-bottom: 10px; 
      text-transform: uppercase; 
      letter-spacing: 0.5px; 
      opacity: 0.7; 
    }
    
    .suggestions-list { display: flex; flex-wrap: wrap; gap: 8px; }
    
    .suggestion-btn { 
      padding: 8px 14px; 
      background: var(--white); 
      border: 1px solid var(--beige); 
      border-radius: 8px; 
      color: var(--charcoal-light); 
      font-size: 12px; 
      cursor: pointer; 
      transition: all 0.2s; 
    }
    
    .suggestion-btn:hover { 
      border-color: var(--charcoal); 
      color: var(--charcoal); 
      background: var(--beige-light); 
    }
    
    .chat-messages { 
      flex: 1; 
      overflow: auto; 
      padding: 24px; 
      display: flex; 
      flex-direction: column; 
      gap: 16px; 
      background: var(--beige-light); 
    }
    
    .message { 
      max-width: 85%; 
      padding: 14px 18px; 
      border-radius: 14px; 
      font-size: 14px; 
      line-height: 1.6; 
      animation: fadeIn 0.3s ease; 
    }
    
    @keyframes fadeIn { 
      from { opacity: 0; transform: translateY(10px); } 
      to { opacity: 1; transform: translateY(0); } 
    }
    
    .message.user { 
      align-self: flex-end; 
      background: var(--charcoal); 
      color: var(--white); 
      border-bottom-right-radius: 4px; 
    }
    
    .message.assistant { 
      align-self: flex-start; 
      background: var(--white); 
      border: 1px solid var(--beige); 
      border-bottom-left-radius: 4px; 
      color: var(--charcoal); 
      box-shadow: 0 2px 8px rgba(52, 54, 51, 0.04); 
    }
    
    .message.assistant p { margin-bottom: 10px; }
    .message.assistant p:last-child { margin-bottom: 0; }
    .message.assistant ul { margin: 8px 0 8px 20px; }
    .message.assistant strong { color: var(--charcoal); font-weight: 600; }
    .message.assistant code { background: var(--beige-light); padding: 2px 5px; border-radius: 3px; font-family: 'IBM Plex Mono', monospace; font-size: 12px; }
    
    .typing { display: flex; gap: 5px; padding: 8px 0; }
    .typing span { width: 8px; height: 8px; background: var(--charcoal-light); border-radius: 50%; animation: bounce 1.4s infinite ease-in-out; opacity: 0.5; }
    .typing span:nth-child(1) { animation-delay: -0.32s; }
    .typing span:nth-child(2) { animation-delay: -0.16s; }
    @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }
    
    .chat-input-area { 
      padding: 18px 24px; 
      border-top: 1px solid var(--beige); 
      background: var(--white); 
    }
    
    .chat-input-wrapper { display: flex; gap: 12px; }
    
    .chat-input { 
      flex: 1; 
      padding: 14px 18px; 
      background: var(--beige-light); 
      border: 1px solid var(--beige); 
      border-radius: 12px; 
      color: var(--charcoal); 
      font-size: 14px; 
      font-family: inherit; 
      resize: none; 
      outline: none; 
      transition: border-color 0.2s; 
    }
    
    .chat-input:focus { border-color: var(--charcoal-light); }
    .chat-input::placeholder { color: var(--charcoal-light); opacity: 0.5; }
    
    .send-btn { 
      width: 52px; 
      height: 52px; 
      border-radius: 12px; 
      border: none; 
      background: var(--charcoal); 
      color: var(--white); 
      cursor: pointer; 
      font-size: 18px; 
      transition: all 0.2s; 
    }
    
    .send-btn:hover { background: var(--charcoal-light); }
    .send-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  </style>
</head>
<body>
  <div class="container">
    <!-- Left: Document List -->
    <div class="doc-panel">
      <div class="doc-header">
        <h2>Documentation</h2>
        <div class="doc-header-sub">Click to expand documents</div>
      </div>
      <div class="doc-list" id="docList">
        <div class="loading-state">Loading documents...</div>
      </div>
    </div>
    
    <!-- Right: Chat -->
    <div class="chat-panel">
      <div class="chat-header">
        <h2>Machinery Servicing Assistant</h2>
        <div class="chat-subtitle">Powered by Vertesia</div>
      </div>
      
      <div class="chat-messages" id="chatMessages">
        <div class="message assistant">
          <p>Hello! I'm your Machinery Servicing Assistant. I can search across all loaded documentation to answer your questions about safety, maintenance, troubleshooting, and parts.</p>
        </div>
      </div>
      
      <div class="chat-input-area">
        <div class="chat-input-wrapper">
          <textarea class="chat-input" id="chatInput" placeholder="Ask about servicing and maintenance..." rows="1" onkeydown="Chat.handleKey(event)"></textarea>
          <button class="send-btn" id="sendBtn" onclick="Chat.send()">â–¶</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      BASE_URL: 'https://api.vertesia.io/api/v1',
      API_KEY: 'sk-780d20f68cd5c5b0682baee88db0af70',
      ENVIRONMENT_ID: '681915c6a01fb262a410c161',
      MODEL: 'publishers/anthropic/models/claude-sonnet-4',
      INTERACTION: 'DocumentChat'  // Must match your Vertesia interaction name exactly
    };

    // ============================================
    // VERTESIA API (Clean implementation)
    // ============================================
    const Vertesia = {
      async call(endpoint, options = {}) {
        const url = `${CONFIG.BASE_URL}${endpoint}`;
        const response = await fetch(url, {
          headers: {
            'Authorization': `Bearer ${CONFIG.API_KEY}`,
            'Content-Type': 'application/json',
            ...options.headers
          },
          ...options
        });
        
        if (!response.ok) {
          const text = await response.text();
          throw new Error(`API ${response.status}: ${text}`);
        }
        
        return response.json();
      },

      // Load all document objects
      async loadObjects() {
        return this.call('/objects?limit=1000');
      },

      // Get single object
      async getObject(id) {
        return this.call(`/objects/${encodeURIComponent(id)}`);
      },

      // Get download URL and fetch content
      async getContent(fileRef) {
        const { url } = await this.call('/objects/download-url', {
          method: 'POST',
          body: JSON.stringify({ file: fileRef, format: 'original' })
        });
        const response = await fetch(url);
        if (!response.ok) throw new Error('Download failed');
        return response.text();
      },

      // Execute async interaction - returns { runId, workflowId }
      async executeChat(task) {
        return this.call('/execute/async', {
          method: 'POST',
          body: JSON.stringify({
            type: 'conversation',
            interaction: CONFIG.INTERACTION,
            data: { task },
            config: {
              environment: CONFIG.ENVIRONMENT_ID,
              model: CONFIG.MODEL
            },
            // These might be needed for the agent to actually run
            interactive: true,
            max_iterations: 100
          })
        });
      },

      // Stream response from workflow run
      async streamResponse(workflowId, runId, onMessage, onComplete, onError) {
        const url = `${CONFIG.BASE_URL}/workflows/runs/${workflowId}/${runId}/stream?since=${Date.now()}&access_token=${CONFIG.API_KEY}`;
        
        console.log('[Stream] Opening:', url);
        
        try {
          const response = await fetch(url);
          
          if (!response.ok) {
            throw new Error(`Stream failed: ${response.status}`);
          }
          
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          
          while (true) {
            const { done, value } = await reader.read();
            
            if (done) {
              console.log('[Stream] Ended');
              onComplete?.();
              break;
            }
            
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop(); // Keep incomplete line
            
            for (const line of lines) {
              if (!line.startsWith('data:')) continue;
              
              try {
                const data = JSON.parse(line.slice(5).trim());
                console.log('[Stream] Data:', data);
                onMessage?.(data);
                
                // Check for completion signals
                if (data.type === 'finish' || data.finish_reason === 'stop') {
                  console.log('[Stream] Complete signal');
                  onComplete?.();
                  return;
                }
              } catch (e) {
                // Ignore parse errors for non-JSON lines
              }
            }
          }
        } catch (error) {
          console.error('[Stream] Error:', error);
          onError?.(error);
        }
      }
    };

    // ============================================
    // DOCUMENT LOADING
    // ============================================
    const Documents = {
      items: [],

      async load() {
        const docList = document.getElementById('docList');
        
        try {
          const data = await Vertesia.loadObjects();
          const objects = Array.isArray(data) ? data : data.objects || [];
          
          console.log(`[Docs] Found ${objects.length} objects`);

          for (const obj of objects) {
            try {
              const fullObj = await Vertesia.getObject(obj.id);
              let content = '';

              // Try to get content from various sources
              if (fullObj.content?.source) {
                const source = fullObj.content.source;
                if (typeof source === 'string') {
                  if (source.startsWith('gs://') || source.startsWith('s3://') || source.includes('/')) {
                    content = await Vertesia.getContent(source);
                  } else {
                    content = source;
                  }
                } else if (typeof source === 'object') {
                  const fileRef = source.file || source.store || source.path;
                  if (fileRef) content = await Vertesia.getContent(fileRef);
                }
              } else if (fullObj.text) {
                content = fullObj.text;
              }

              if (content && content.length > 50) {
                this.items.push({
                  id: obj.id,
                  name: obj.name || 'Untitled',
                  content: content
                });
                console.log(`[Docs] Loaded: ${obj.name}`);
              }
            } catch (err) {
              console.warn(`[Docs] Failed: ${obj.name}`, err.message);
            }
          }

          if (this.items.length === 0) {
            docList.innerHTML = '<div class="error-state">No documents found</div>';
            return;
          }

          this.render();

        } catch (error) {
          console.error('[Docs] Load failed:', error);
          docList.innerHTML = `<div class="error-state">Failed to load: ${error.message}</div>`;
        }
      },

      render() {
        const docList = document.getElementById('docList');
        
        docList.innerHTML = this.items.map((doc, i) => `
          <div class="doc-item" id="doc-${i}">
            <div class="doc-item-header" onclick="Documents.toggle(${i})">
              <div class="doc-item-info">
                <div class="doc-item-icon">ðŸ“„</div>
                <div>
                  <div class="doc-item-title">${this.escapeHtml(doc.name)}</div>
                  <div class="doc-item-meta">${this.formatSize(doc.content.length)} â€¢ ${i + 1} of ${this.items.length}</div>
                </div>
              </div>
              <div class="doc-item-toggle">â–¼</div>
            </div>
            <div class="doc-item-content" id="doc-content-${i}"></div>
          </div>
        `).join('');
      },

      toggle(index) {
        const item = document.getElementById(`doc-${index}`);
        const content = document.getElementById(`doc-content-${index}`);
        
        // Close all others
        document.querySelectorAll('.doc-item').forEach((el, i) => {
          if (i !== index) el.classList.remove('expanded');
        });
        
        // Toggle this one
        const isExpanded = item.classList.toggle('expanded');
        
        // Render content if expanding (lazy load)
        if (isExpanded && !content.innerHTML) {
          content.innerHTML = marked.parse(this.items[index].content);
        }
      },

      formatSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ============================================
    // CHAT (Clean implementation with progress)
    // ============================================
    const Chat = {
      history: [],
      isLoading: false,

      async send() {
        const input = document.getElementById('chatInput');
        const question = input.value.trim();
        
        if (!question || this.isLoading) return;

        input.value = '';
        this.setLoading(true);
        this.addMessage(question, 'user');
        
        // Show status indicator instead of just dots
        const statusEl = this.showStatus('Connecting...');

        try {
          // Build task string with conversation history
          let task = question;
          if (this.history.length > 0) {
            const historyStr = this.history
              .map(m => `${m.role === 'user' ? 'User' : 'Assistant'}: ${m.content}`)
              .join('\n');
            task = `Previous conversation:\n${historyStr}\n\nCurrent question: ${question}`;
          }

          console.log('[Chat] Sending task:', task);

          // Execute async - get runId and workflowId
          const response = await Vertesia.executeChat(task);
          
          console.log('[Chat] Full response:', response);
          
          const runId = response.runId || response.run_id;
          const workflowId = response.workflowId || response.workflow_id;
          
          console.log('[Chat] runId:', runId, 'workflowId:', workflowId);

          if (!runId || !workflowId) {
            throw new Error('Missing runId or workflowId in response');
          }

          this.updateStatus(statusEl, 'Processing...');

          // Stream the response
          let answer = '';
          let answered = false;
          let streamingText = '';
          let messageEl = null;

          await Vertesia.streamResponse(
            workflowId,
            runId,
            // onMessage
            (data) => {
              console.log('[Chat] Stream data:', JSON.stringify(data, null, 2));
              
              // Update status with progress messages
              if (data.type === 'update' && data.message) {
                this.updateStatus(statusEl, data.message);
              }
              
              // Check for answer in multiple formats
              // Format 1: type: "answer" with message
              if (data.type === 'answer' && data.message && !answered) {
                answered = true;
                answer = data.message;
                statusEl.remove();
                this.addMessage(answer, 'assistant');
                return;
              }
              
              // Format 2: type: "complete" with result/content
              if (data.type === 'complete' && !answered) {
                const content = data.result || data.content || data.message || data.output;
                if (content) {
                  answered = true;
                  answer = typeof content === 'string' ? content : JSON.stringify(content);
                  statusEl.remove();
                  this.addMessage(answer, 'assistant');
                  return;
                }
              }
              
              // Format 3: Streaming text chunks (delta/content/text)
              const chunk = data.delta || data.content || data.text;
              if (chunk && typeof chunk === 'string' && !answered) {
                streamingText += chunk;
                if (!messageEl) {
                  statusEl.remove();
                  messageEl = this.addMessage(streamingText, 'assistant');
                } else {
                  messageEl.innerHTML = marked.parse(streamingText);
                }
              }
              
              // Format 4: Direct message field (not an update)
              if (data.message && data.type !== 'update' && !answered) {
                answered = true;
                answer = data.message;
                statusEl.remove();
                this.addMessage(answer, 'assistant');
                return;
              }
            },
            // onComplete
            () => {
              console.log('[Chat] Stream complete. Answered:', answered, 'StreamingText:', streamingText.length);
              
              // If we got streaming text, that's our answer
              if (streamingText && !answered) {
                answered = true;
                answer = streamingText;
              }
              
              if (!answered) {
                statusEl.remove();
                this.addMessage('The agent completed but returned no response. Check console for details.', 'assistant');
              }
              this.setLoading(false);
            },
            // onError
            (error) => {
              statusEl.remove();
              this.addMessage(`Error: ${error.message}`, 'assistant');
              this.setLoading(false);
            }
          );

          // Save to history
          this.history.push({ role: 'user', content: question });
          if (answer) {
            this.history.push({ role: 'assistant', content: answer });
          }

        } catch (error) {
          console.error('[Chat] Error:', error);
          statusEl.remove();
          this.addMessage(`Error: ${error.message}`, 'assistant');
          this.setLoading(false);
        }
      },

      addMessage(text, role) {
        const container = document.getElementById('chatMessages');
        const div = document.createElement('div');
        div.className = `message ${role}`;
        div.innerHTML = role === 'assistant' ? marked.parse(text) : Documents.escapeHtml(text);
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
        return div;
      },

      showStatus(text) {
        const container = document.getElementById('chatMessages');
        const div = document.createElement('div');
        div.className = 'message assistant status-message';
        div.innerHTML = `
          <div style="display: flex; align-items: center; gap: 10px;">
            <div class="typing"><span></span><span></span><span></span></div>
            <span class="status-text" style="font-size: 12px; opacity: 0.7;">${Documents.escapeHtml(text)}</span>
          </div>
        `;
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
        return div;
      },
      
      updateStatus(el, text) {
        const statusText = el.querySelector('.status-text');
        if (statusText) {
          statusText.textContent = text;
        }
      },

      setLoading(loading) {
        this.isLoading = loading;
        document.getElementById('sendBtn').disabled = loading;
        document.getElementById('chatInput').disabled = loading;
      },

      handleKey(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.send();
        }
      },

      ask(question) {
        document.getElementById('chatInput').value = question;
        this.send();
      }
    };

    // ============================================
    // INIT
    // ============================================
    Documents.load();
  </script>
</body>
</html>
